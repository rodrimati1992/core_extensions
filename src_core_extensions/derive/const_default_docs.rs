/// Derives the [`ConstDefault`] trait.
/// 
/// [For examples look here](examples)
/// 
/// # Attributes
/// 
/// ### Container attributes
/// 
/// Attributes used above the type definition.
/// 
/// `#[cdef(crate = foo::bar)]`
/// Replaces the path to `core_extensions` with `foo::bar`
/// 
/// `#[cdef(bound(T: Foo + Bar))]`:
/// Replaces the bound of the T type parameter with the passed-in bounds.
///
/// This allows `#[cdef(bound(T: ))]`, removing the bounds for that type parameter.
/// 
/// `#[cdef(no_bounds)]`:
/// Removes `ConstDefault` bound for all type parameters
/// 
/// `#[cdef(field_bound)]`:
/// Removes the `ConstDefault` bound for type parameters,
/// replacing them with bounds on field types.
/// 
/// `#[cdef(debug_print)]`:
/// For diagnostics, causes the derive macro to panic with the code generated by it.
/// 
/// ### Variant attributes
/// 
/// `#[cdef(default)]`:
/// Uses that variant for the default value.
/// 
/// ### Field attributes
/// 
/// `#[cdef(default = <expression>)]`:
/// Replaces the default value of the field ([`ConstDefault::DEFAULT`]) with `<expression>`.
/// 
/// `#[cdef(field_bound)]`:
/// Adds a [`ConstDefault`] bound for the field type.
/// 
/// # Examples
/// 
/// ### Basic
/// 
/// ```rust
/// use core_extensions::ConstDefault;
/// 
/// #[derive(Debug, PartialEq, ConstDefault)]
/// struct Foo {
///     bar: u32,
///     baz: Option<String>,
/// }
/// 
/// assert_eq!(Foo::DEFAULT, Foo{bar: 0, baz: None});
/// 
/// 
/// ```
/// 
/// [`ConstDefault::DEFAULT`]: ./trait.ConstDefault.html#associatedconstant.DEFAULT
/// [`ConstDefault`]: ./trait.ConstDefault.html
#[cfg_attr(feature = "docsrs", doc(cfg(all(feature = "derive", feature = "const_default"))))]
pub use core_extensions_proc_macros::ConstDefault;